<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Drake setup and introduction to IK using pseudo inverse and quadratic programming | Pk blog</title>
<meta name=keywords content="Drake,Manipulation,Robotics,Introduction"><meta name=description content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester."><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/hacking_robotics/drake_introduction/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/hacking_robotics/drake_introduction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Drake setup and introduction to IK using pseudo inverse and quadratic programming"><meta property="og:description" content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/hacking_robotics/drake_introduction/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="hacking_robotics"><meta property="article:published_time" content="2023-10-15T18:49:58-05:00"><meta property="article:modified_time" content="2023-10-15T18:49:58-05:00"><meta property="og:site_name" content="PK's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Drake setup and introduction to IK using pseudo inverse and quadratic programming"><meta name=twitter:description content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Hacking_robotics","item":"http://localhost:1313/hacking_robotics/"},{"@type":"ListItem","position":2,"name":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","item":"http://localhost:1313/hacking_robotics/drake_introduction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","name":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","description":"Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.\nSetup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.","keywords":["Drake","Manipulation","Robotics","Introduction"],"articleBody":"Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.\nSetup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.\nThis document will run the simple pick \u0026 place example from the course and also add some of my own functions to switch the solving type.\nSetup for this tutorials are as follows: clone the repository: git clone https://github.com/Prakyathkantharaju/Hacking-robotics Setup python env Install python version of drake. pip install pydrake In the robotics directory, clone the manipulation repository, I am not sure if this is also a pip installable package but I prefer to clone the repository as you can edit yaml file to add your own robot. git clone https://github.com/RussTedrake/manipulation I will be using loading and viusalizations tools from the repository, I will be adding the location of this repository to the python path in the next step.\nimport sys sys.path.append('../manipulation') Running the pick and place example The full python file is located in robotics/drake/pick_plane_inverse_qp.py\nI will break the code into sections and explain each section here.\nImporting the necessary libraries NOTE: I have the manipulator library in the robotics/drake/manipulation directory, so I am adding that to the python path. If you have installed the manipulation library as a pip package, you can skip this step. If you have cloned the manipulation repository, you can add the path to the python path. # loading the python libraries import numpy as np import matplotlib.pyplot as plt import pydot # loading the drake variables from pydrake.all import ( AddMultibodyPlantSceneGraph, AngleAxis, Context, DiagramBuilder, Integrator, JacobianWrtVariable, LeafSystem, MeshcatVisualizer, MultibodyPlant, MultibodyPositionToGeometryPose, Parser, PiecewisePolynomial, PiecewisePose, Quaternion, Rgba, RigidTransform, RotationMatrix, SceneGraph, Simulator, StartMeshcat, SystemOutput, TrajectorySource, MathematicalProgram, Solve, ) import sys sys.path.append('manipulation/') from manipulation.scenarios import AddMultibodyPlantSceneGraph from manipulation.station import MakeHardwareStation, load_scenario Loading the robot and the environment Here we are loading the meshcat server, which is a visualization tool for drake. After that we are loading the scenario, which is a yaml file that has the robot and the environment information. We use the diagram builder to add the scenario to the diagram. # start the meshcat server meshcat = StartMeshcat() # scenario scenario = \\ \"\"\" directives: - add_directives: file: package://manipulation/clutter.dmd.yaml - add_model: name: foam_brick file: package://manipulation/hydro/061_foam_brick.sdf model_drivers: iiwa: !IiwaDriver hand_model_name: wsg wsg: !SchunkWsgDriver {} \"\"\" # start with some blank diagram builder = DiagramBuilder() # loading the scenriao using the yaml string above. scenario = load_scenario(data=scenario) # adding scenario to the diagram, the scenario has two parts, iiwa and the wsg. you can visualize this in the diagram. station = builder.AddSystem(MakeHardwareStation( scenario=scenario, meshcat=meshcat)) Setting the default pose for the robot. Here are getting the plant for the robot and setting the default pose for the elements in the diagram. # get the plant plant = station.GetSubsystemByName(\"plant\") # set the pose for the body plant.SetDefaultFreeBodyPose(plant.GetBodyByName(\"base_link\"), RigidTransform(RotationMatrix.MakeZRotation(np.pi/2), [0,-0.6,0])) # set the pose for the gripper get_context = station.CreateDefaultContext() plant_context = plant.GetMyContextFromRoot(get_context) Generating the trajectories for the robot. First we have set the initial and final pose for the robot. This is predetermined, I did not change it. Both in the body frame and the world frame, here is the code for that: # making trajectory X_G = {\"initial\": plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(\"body\")), \"goal\": RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame X_O = {\"initial\": plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(\"base_link\")), # x with respect to the body frame \"goal\": RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame Now using this start and end point, we make the trajectory for the end effector for the robot here is the code for that. So this is a big function, which I intend to break down into smaller functions later. But let me go step by step what is happening here.\nFirst I use the start and end point and get the parts of the trajectory that are predetermined, like the pregrasp, grasp, preplace, place, etc. Then we set the time between the trajectory points, this is also predetermined, I did not change it. After this I use the piecewise linear function to interpolate the trajectory between the points. Then I differentiate the trajectory to get the velocity trajectory. Then I plot the trajectory, this is just for visualization if the plot flag is set to True. # making the trajectory for the end effector def make_trajectory(X_WG: dict, X_WO: dict, plot:bool =True): \"\"\" Takes a partial specification with X_G[\"initial\"] and X_O[\"initial\"] and X_0[\"goal\"], and returns a X_G and times with all of the pick and place frames populated. \"\"\" X_G = { \"initial\": RigidTransform(RotationMatrix.MakeXRotation(-np.pi / 2.0), [0, -0.25, 0.25]) } # TODO(prakyath) THIS IS COPIED FROM THE PICK NOTEBOOK, BUT YOU'LL NEED TO MODIFY IT FOR WITH RL LATER. # Define (again) the gripper pose relative to the object when in grasp. p_GgraspO = [0, 0.12, 0] R_GgraspO = RotationMatrix.MakeXRotation( np.pi / 2.0 ) @ RotationMatrix.MakeZRotation(np.pi / 2.0) X_GgraspO = RigidTransform(R_GgraspO, p_GgraspO) X_OGgrasp = X_GgraspO.inverse() # pregrasp is negative y in the gripper frame (see the figure!). X_GgraspGpregrasp = RigidTransform([0, -0.08, 0]) X_WG[\"pick\"] = X_WO[\"initial\"] @ X_OGgrasp X_WG[\"prepick\"] = X_WG[\"pick\"] @ X_GgraspGpregrasp X_WG[\"place\"] = X_WO[\"goal\"] @ X_OGgrasp X_WG[\"preplace\"] = X_WG[\"place\"] @ X_GgraspGpregrasp # I'll interpolate a halfway orientation by converting to axis angle and halving the angle. X_GprepickGpreplace = X_WG[\"prepick\"].inverse() @ X_WG[\"preplace\"] angle_axis = X_GprepickGpreplace.rotation().ToAngleAxis() X_GprepickGclearance = RigidTransform( AngleAxis(angle=angle_axis.angle() / 2.0, axis=angle_axis.axis()), X_GprepickGpreplace.translation() / 2.0 + np.array([0, -0.3, 0]), ) X_WG[\"clearance\"] = X_WG[\"prepick\"] @ X_GprepickGclearance # Now let's set the timing times = {\"initial\": 0} X_GinitialGprepick = X_G[\"initial\"].inverse() @ X_WG[\"prepick\"] times[\"prepick\"] = times[\"initial\"] + 10.0 * np.linalg.norm( X_GinitialGprepick.translation() ) # Allow some time for the gripper to close. times[\"pick_start\"] = times[\"prepick\"] + 2.0 times[\"pick_end\"] = times[\"pick_start\"] + 2.0 X_WG[\"pick_start\"] = X_WG[\"pick\"] X_WG[\"pick_end\"] = X_WG[\"pick\"] times[\"postpick\"] = times[\"pick_end\"] + 2.0 X_WG[\"postpick\"] = X_WG[\"prepick\"] time_to_from_clearance = 10.0 * np.linalg.norm( X_GprepickGclearance.translation() ) times[\"clearance\"] = times[\"postpick\"] + time_to_from_clearance times[\"preplace\"] = times[\"clearance\"] + time_to_from_clearance times[\"place_start\"] = times[\"preplace\"] + 2.0 times[\"place_end\"] = times[\"place_start\"] + 2.0 X_WG[\"place_start\"] = X_WG[\"place\"] X_WG[\"place_end\"] = X_WG[\"place\"] times[\"postplace\"] = times[\"place_end\"] + 2.0 X_WG[\"postplace\"] = X_WG[\"preplace\"] # combine all the tiem and tracjectories. sample_times = [] X_WG_traj = [] for name in [ \"initial\", \"prepick\", \"pick_start\", \"pick_end\", \"postpick\", \"clearance\", \"preplace\", \"place_start\", \"place_end\", \"postplace\", ]: sample_times.append(times[name]) X_WG_traj.append(X_WG[name]) print(name, X_WG[name].translation()) # Do a piecewise linear interpolation. traj_position_G = PiecewisePose.MakeLinear(sample_times, X_WG_traj) print(traj_position_G) # Get the trajectories in velocity though differentiation. traj_velocity_G = traj_position_G.MakeDerivative() # Now let's plot the trajectory. if plot: fig, ax = plt.subplots() plot_time = traj_velocity_G.get_segment_times() plot_V_WG = traj_velocity_G.vector_values(plot_time) plt.plot(plot_time, plot_V_WG.T) ax.legend() plt.show() return X_WG, times, traj_velocity_G Setting up the gripper trajectory. Since the gripper is a separate entity, we need to set the trajectory for the gripper separately. Here we are using the a zero-order-trajectory, i.e it will be actuated at a distinct time. All these time are predetermined and follows the trajectory of the end effector.\n# making the gripper trajectory def MakeGripperCommandTrajectory(times): opened = np.array([0.107]) closed = np.array([0.0]) traj_wsg_command = PiecewisePolynomial.FirstOrderHold( [times[\"initial\"], times[\"pick_start\"]], np.hstack([[opened], [opened]]), ) traj_wsg_command.AppendFirstOrderSegment(times[\"pick_end\"], closed) traj_wsg_command.AppendFirstOrderSegment(times[\"place_start\"], closed) traj_wsg_command.AppendFirstOrderSegment(times[\"place_end\"], opened) traj_wsg_command.AppendFirstOrderSegment(times[\"postplace\"], opened) return traj_wsg_command Add these trajectories to the diagram. Position_X, times, vel_trajectory = make_trajectory(X_G, X_O, plot=True) # gripper position traj_wsg_command = MakeGripperCommandTrajectory(times) # add the trajectory to the diagram V_G_source = builder.AddSystem(TrajectorySource(vel_trajectory)) V_G_source.set_name(\"V_G_source\") Setting up the inverse kinematics controller for the robot. For this I using two different methods, one is the pseudo inverse and the other is the qp (quadratic programming). Both controller are leaf systems, which means I can connect to the diagram as a system. I will explain the pseudo inverse controller first and then I will explain the qp controller.\nPseudo inverse controller Initialization in __init__:\nInitialize the leaf super class. Store the plant context, this will help get the positions and vel of the robot. Get the model instance for the robot. Get the body frame and the world frame for the robot. Get the start and end joints for the robot, this will help get the jacobian for the robot. Set the input port of the leafsystem, this is essentially a input port to our system, in this case we are taking the desired vel from trajectory source. In addition to the desired vel, we also need the position of the robot, so we are setting another input port for the position of the robot. Set the output port of the leafsystem, this is an output port to our system, in this case we are giving the desired vel to the robot. We are also connecting the output port to the function which will calculate the actual output. In my case this will be CalcOutput function. CalcOutput function:\nGet the current position of the robot and the desired vel from the input port by using the diagram context. I set the plant pose based on the position, then calculate the jacobian of the robot with respoect to the end joint. then removing the unwanted joints from the jacobian. then I calculate the pseudo inverse of the jacobian and multiply it with the desired vel to get the actual vel. class PseudoInverseController(LeafSystem): def __init__(self, plant: MultibodyPlant): super().__init__() # store the plant for the controller use in future self._plant = plant # get the default context for the plant for the differential kinematics self._get_plant_context = plant.CreateDefaultContext() # get the model instance for the iiwa self._iiwa = plant.GetModelInstanceByName(\"iiwa\") # these two are for views and transformations self._g = plant.GetBodyByName(\"body\").body_frame() self._w = plant.world_frame() # get the start and end joints self._start_joint = plant.GetJointByName(\"iiwa_joint_1\").velocity_start() self._end_joint = plant.GetJointByName(\"iiwa_joint_7\").velocity_start() # start declaring the inputs nad output ports # input port for the desired velocity self.vel_input_port = self.DeclareVectorInputPort(\"V_WG\", 6) # input port for the position of the robot self.q_word = self.DeclareVectorInputPort(\"iiwa.position\", 7) # output port for the desired velocity self.DeclareVectorOutputPort(\"iiwa.velocity\", 7, self.CalcOutput) # this is optional to store the trajectory data. self.save_data = [] def CalcOutput(self, context, output): # get the current position of the robot q = self.q_word.Eval(context) # get the current velocity of the robot v = self.vel_input_port.Eval(context) # set the position to the robot. Still not sure why we need to do this. self._plant.SetPositions(self._get_plant_context, self._iiwa, q) # get the jacobian of the robot J = self._plant.CalcJacobianSpatialVelocity( self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w ) J = J[:, self._start_joint : self._end_joint + 1] v = np.linalg.pinv(J).dot(v) self.save_data.append(v) output.SetFromVector(v) QP controller The next is the qp controller, this is a bit more complicated than the pseudo inverse controller. Initialization in __init__:\nInitialization is same as the pseudo inverse controller. In addition I also initializing a variable which will store the jacobian and the desired vel. CalcOutput function:\nStarting part of the function is same as the pseudo inverse controller. After I find the jacobian, I solving a quadratic programming problem to find the actual vel, using the drake math program solver Solve. I am using the Solve function to solve the mathmatical problem, which is defined in the _define_math_problem function. _define_math_problem function:\nThis function is used to define the mathmatical problem for the qp solver. I am using the MathematicalProgram class to define the problem. I add the continous variable to the problem, which is the actual vel. ( here I am 15 variables, because the jacobian is also 6 * 15, there are some useless joints there, I kept it for fun, you can remove it if you want) I add the bounding box constraint to the problem, this is to make sure the vel is within the limits. I also calculate the error using the following equation $error = J * v - v_{desired}$ I add the cost to the problem, which is the error dot product with itself ( this make the error quadratic, which is needed for the qp solver) I return the problem to the solve. #TODO Need to make a controller super class in the future class QPController(LeafSystem): def __init__(self, plant: MultibodyPlant): super().__init__() # store the plant for the controller use in future self._plant = plant # get the default context for the plant for the differential kinematics self._get_plant_context = plant.CreateDefaultContext() # get the model instance for the iiwa self._iiwa = plant.GetModelInstanceByName(\"iiwa\") # these two are for views and transformations self._g = plant.GetBodyByName(\"body\").body_frame() self._w = plant.world_frame() # get the start and end joints self._start_joint = plant.GetJointByName(\"iiwa_joint_1\").velocity_start() self._end_joint = plant.GetJointByName(\"iiwa_joint_7\").velocity_start() # start declaring the inputs nad output ports self.vel_input_port = self.DeclareVectorInputPort(\"V_WG\", 6) self.q_word = self.DeclareVectorInputPort(\"iiwa.position\", 7) self.DeclareVectorOutputPort(\"iiwa.velocity\", 7, self.CalcOutput) self.save_data = [] # Initialize the J and x with None self.J = None self.v = None def _define_math_problem(self, v_desired: np.ndarray): prog = MathematicalProgram() v = prog.NewContinuousVariables(15, \"v\") v_max = 0.5 error = self.J @ v - np.array(v_desired) prog.AddBoundingBoxConstraint(-v_max, v_max, v) prog.AddCost(error.dot(error)) return prog def CalcOutput(self, context: Context, outputs: SystemOutput) -\u003e None: # get the current position of the robot q = self.q_word.Eval(context) # get the current velocity of the robot v = self.vel_input_port.Eval(context) # set the position to the robot. Still not sure why we need to do this. self._plant.SetPositions(self._get_plant_context, self._iiwa, q) # get the jacobian of the robot self.J = self._plant.CalcJacobianSpatialVelocity( self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w ) # print(v.shape, v) result = Solve(self._define_math_problem(v)) r = result.GetSolution(v) v = result.get_x_val()[:7] # print(result.get_x_val()[:7], \"This is the x val results\") # print(r.shape, r) # v = np.array([print(dir(c[0])) for c in r]) self.save_data.append(v) # print(v) # print(\"v\", v, dir(v), type(v)) # print(np.array(v), dir(v), type(v)) outputs.SetFromVector(v) Adding the controllers to the diagram. # add the controller to the diagram controller = builder.AddSystem(PseudoInverseController(plant)) # controller = builder.AddSystem(QPController(plant)) Add the integrator to the diagram. Since the controller return the vel, we need to integrate it to get the position. # add the integrator to the diagram integrator = builder.AddSystem(Integrator(7)) Make all the connections. # connections between the systems # 1. connect the desired velocity to the controller builder.Connect(V_G_source.get_output_port(), controller.GetInputPort(\"V_WG\")) # 2. connect the output of the controller to the integrator builder.Connect(controller.get_output_port(), integrator.get_input_port()) # 3. connect the integrator to the iiwa position builder.Connect(integrator.get_output_port(), station.GetInputPort(\"iiwa.position\")) # 4. connect the iiwa state to the controller builder.Connect(station.GetOutputPort(\"iiwa.position_measured\"), controller.GetInputPort(\"iiwa.position\")) # calcualte connecting the gripper wsg_source = builder.AddSystem(TrajectorySource(traj_wsg_command)) wsg_source.set_name(\"wsg.command\") # 5. gripper position to the station builder.Connect(wsg_source.get_output_port(), station.GetInputPort(\"wsg.position\")) diagram = builder.Build() diagram.set_name(\"Testing_pick_and_place\") Visualize the diagram using pydot. I love this part of drake a LOT. # visualize the diagram print(\"Diagram built\") pydot.graph_from_dot_data( diagram.GetGraphvizString())[0].write_svg(\"station_pick_place.svg\") Simulate the system. # simulate the diagram simulator = Simulator(diagram) context = simulator.get_mutable_context() station_context = station.GetMyContextFromRoot(context) integrator.set_integral_value(integrator.GetMyContextFromRoot(context), plant.GetPositions( plant.GetMyContextFromRoot(context), plant.GetModelInstanceByName(\"iiwa\"), ), ) diagram.ForcedPublish(context) meshcat.StartRecording(set_visualizations_while_recording=True) simulator.AdvanceTo(vel_trajectory.end_time()) meshcat.StopRecording() meshcat.PublishRecording() Plot the results. plt.plot(np.array(controller.save_data).reshape(-1,7)) plt.show() Results I tried embedding video, but hugo is not letting me, so here is the youtube video: https://youtu.be/rtCUpqlqp20\n","wordCount":"2444","inLanguage":"en","datePublished":"2023-10-15T18:49:58-05:00","dateModified":"2023-10-15T18:49:58-05:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/hacking_robotics/drake_introduction/"},"publisher":{"@type":"Organization","name":"Pk blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Prakyath Kantharaju's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Prakyath Kantharaju's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/prakyathkantharaju title=github.com><span>github.com</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/hacking_robotics/>Hacking_robotics</a></div><h1 class="post-title entry-hint-parent">Drake setup and introduction to IK using pseudo inverse and quadratic programming</h1><div class=post-meta><span title='2023-10-15 18:49:58 -0500 CDT'>October 15, 2023</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2444 words&nbsp;·&nbsp;Me</div></header><div class=post-content><h1 id=introduction-to-drake>Introduction to Drake<a hidden class=anchor aria-hidden=true href=#introduction-to-drake>#</a></h1><p>Drake is a C++ toolbox started by Russ Tedrake and his group at MIT.
It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.</p><h1 id=setup-for-manipulation>Setup for manipulation<a hidden class=anchor aria-hidden=true href=#setup-for-manipulation>#</a></h1><p>In this project I am borrowing most of the work from the <a href=https://github.com/RussTedrake/manipulation>Drake manipulation repository</a>, which is used to teach the manipulators course at MIT.
Here are the course documents: <a href=http://manipulation.csail.mit.edu/>manipulation</a> and <a href="https://youtube.com/playlist?list=PLkx8KyIQkMfUSDs2hvTWzaq-cxGl8Ha69&amp;si=xwgcVbpWYG-cGHDa">Manipulation youtube playlist from last semester</a>.</p><p>This document will run the simple pick & place example from the course and also add some of my own functions to switch the solving type.</p><h2 id=setup-for-this-tutorials-are-as-follows>Setup for this tutorials are as follows:<a hidden class=anchor aria-hidden=true href=#setup-for-this-tutorials-are-as-follows>#</a></h2><ol><li>clone the repository:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone https://github.com/Prakyathkantharaju/Hacking-robotics
</span></span></code></pre></div><ol start=2><li>Setup python env
Install python version of drake.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install pydrake
</span></span></code></pre></div><ol start=3><li>In the robotics directory, clone the manipulation repository, I am not sure if this is also a pip installable package but I prefer to clone the repository as you can edit yaml file to add your own robot.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone https://github.com/RussTedrake/manipulation
</span></span></code></pre></div><p>I will be using loading and viusalizations tools from the repository, I will be adding the location of this repository to the python path in the next step.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import sys
</span></span><span class=line><span class=cl>sys.path.append(&#39;../manipulation&#39;)
</span></span></code></pre></div><h2 id=running-the-pick-and-place-example>Running the pick and place example<a hidden class=anchor aria-hidden=true href=#running-the-pick-and-place-example>#</a></h2><p>The full python file is located in <code>robotics/drake/pick_plane_inverse_qp.py</code></p><p>I will break the code into sections and explain each section here.</p><ol><li>Importing the necessary libraries
NOTE: I have the manipulator library in the robotics/drake/manipulation directory, so I am adding that to the python path. If you have installed the manipulation library as a pip package, you can skip this step. If you have cloned the manipulation repository, you can add the path to the python path.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1># loading the python libraries</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>numpy</span> <span class=n>as</span> <span class=n>np</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>matplotlib</span><span class=o>.</span><span class=n>pyplot</span> <span class=n>as</span> <span class=n>plt</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>pydot</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># loading the drake variables</span>
</span></span><span class=line><span class=cl><span class=n>from</span> <span class=n>pydrake</span><span class=o>.</span><span class=n>all</span> <span class=n>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>AddMultibodyPlantSceneGraph</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>AngleAxis</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Context</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DiagramBuilder</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Integrator</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>JacobianWrtVariable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LeafSystem</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MeshcatVisualizer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MultibodyPlant</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MultibodyPositionToGeometryPose</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Parser</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PiecewisePolynomial</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PiecewisePose</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Quaternion</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Rgba</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RigidTransform</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>RotationMatrix</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SceneGraph</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Simulator</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>StartMeshcat</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SystemOutput</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TrajectorySource</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MathematicalProgram</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Solve</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;manipulation/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>from</span> <span class=n>manipulation</span><span class=o>.</span><span class=n>scenarios</span> <span class=n>import</span> <span class=n>AddMultibodyPlantSceneGraph</span>
</span></span><span class=line><span class=cl><span class=n>from</span> <span class=n>manipulation</span><span class=o>.</span><span class=n>station</span> <span class=n>import</span> <span class=n>MakeHardwareStation</span><span class=p>,</span> <span class=n>load_scenario</span>
</span></span></code></pre></div><ol start=2><li>Loading the robot and the environment
Here we are loading the meshcat server, which is a visualization tool for drake.
After that we are loading the scenario, which is a yaml file that has the robot and the environment information.
We use the diagram builder to add the scenario to the diagram.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>    <span class=c1># start the meshcat server</span>
</span></span><span class=line><span class=cl>    <span class=n>meshcat</span> <span class=o>=</span> <span class=n>StartMeshcat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># scenario</span>
</span></span><span class=line><span class=cl>    <span class=n>scenario</span> <span class=o>=</span> \
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    directives:
</span></span></span><span class=line><span class=cl><span class=s2>    - add_directives:
</span></span></span><span class=line><span class=cl><span class=s2>        file: package://manipulation/clutter.dmd.yaml
</span></span></span><span class=line><span class=cl><span class=s2>    - add_model:
</span></span></span><span class=line><span class=cl><span class=s2>        name: foam_brick
</span></span></span><span class=line><span class=cl><span class=s2>        file: package://manipulation/hydro/061_foam_brick.sdf
</span></span></span><span class=line><span class=cl><span class=s2>    model_drivers:
</span></span></span><span class=line><span class=cl><span class=s2>        iiwa: !IiwaDriver
</span></span></span><span class=line><span class=cl><span class=s2>            hand_model_name: wsg
</span></span></span><span class=line><span class=cl><span class=s2>        wsg: !SchunkWsgDriver {}
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># start with some blank diagram</span>
</span></span><span class=line><span class=cl>    <span class=n>builder</span> <span class=o>=</span> <span class=n>DiagramBuilder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># loading the scenriao using the yaml string above.</span>
</span></span><span class=line><span class=cl>    <span class=n>scenario</span> <span class=o>=</span> <span class=n>load_scenario</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=n>scenario</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># adding scenario to the diagram, the scenario has two parts, iiwa and the wsg. you can visualize this in the diagram.</span>
</span></span><span class=line><span class=cl>    <span class=n>station</span> <span class=o>=</span> <span class=n>builder</span><span class=o>.</span><span class=n>AddSystem</span><span class=p>(</span><span class=n>MakeHardwareStation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>scenario</span><span class=o>=</span><span class=n>scenario</span><span class=p>,</span> <span class=n>meshcat</span><span class=o>=</span><span class=n>meshcat</span><span class=p>))</span>
</span></span></code></pre></div><ol start=3><li>Setting the default pose for the robot.
Here are getting the plant for the robot and setting the default pose for the elements in the diagram.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # get the plant
</span></span><span class=line><span class=cl>    plant = station.GetSubsystemByName(&#34;plant&#34;)
</span></span><span class=line><span class=cl>    # set the pose for the body
</span></span><span class=line><span class=cl>    plant.SetDefaultFreeBodyPose(plant.GetBodyByName(&#34;base_link&#34;), 
</span></span><span class=line><span class=cl>                                 RigidTransform(RotationMatrix.MakeZRotation(np.pi/2), [0,-0.6,0]))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # set the pose for the gripper 
</span></span><span class=line><span class=cl>    get_context = station.CreateDefaultContext()
</span></span><span class=line><span class=cl>    plant_context = plant.GetMyContextFromRoot(get_context)
</span></span></code></pre></div><ol start=4><li>Generating the trajectories for the robot.
First we have set the initial and final pose for the robot.
This is predetermined, I did not change it.
Both in the body frame and the world frame, here is the code for that:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # making trajectory
</span></span><span class=line><span class=cl>    X_G = {&#34;initial&#34;: plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(&#34;body&#34;)),
</span></span><span class=line><span class=cl>           &#34;goal&#34;: RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame
</span></span><span class=line><span class=cl>    X_O = {&#34;initial&#34;: plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(&#34;base_link&#34;)), # x with respect to the body frame
</span></span><span class=line><span class=cl>           &#34;goal&#34;: RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame
</span></span></code></pre></div><p>Now using this start and end point, we make the trajectory for the end effector for the robot here is the code for that.
So this is a big function, which I intend to break down into smaller functions later. But let me go step by step what is happening here.</p><ul><li>First I use the start and end point and get the parts of the trajectory that are predetermined, like the pregrasp, grasp, preplace, place, etc.</li><li>Then we set the time between the trajectory points, this is also predetermined, I did not change it.</li><li>After this I use the piecewise linear function to interpolate the trajectory between the points.</li><li>Then I differentiate the trajectory to get the velocity trajectory.</li><li>Then I plot the trajectory, this is just for visualization if the <code>plot</code> flag is set to <code>True</code>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # making the trajectory for the end effector
</span></span><span class=line><span class=cl>def make_trajectory(X_WG: dict, X_WO: dict, plot:bool =True):
</span></span><span class=line><span class=cl>    &#34;&#34;&#34;
</span></span><span class=line><span class=cl>    Takes a partial specification with X_G[&#34;initial&#34;] and X_O[&#34;initial&#34;] and
</span></span><span class=line><span class=cl>    X_0[&#34;goal&#34;], and returns a X_G and times with all of the pick and place
</span></span><span class=line><span class=cl>    frames populated.
</span></span><span class=line><span class=cl>    &#34;&#34;&#34;
</span></span><span class=line><span class=cl>    X_G = { &#34;initial&#34;: RigidTransform(RotationMatrix.MakeXRotation(-np.pi / 2.0), [0, -0.25, 0.25]) }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # TODO(prakyath) THIS IS COPIED FROM THE PICK NOTEBOOK, BUT YOU&#39;LL NEED TO MODIFY IT FOR WITH RL LATER.
</span></span><span class=line><span class=cl>    # Define (again) the gripper pose relative to the object when in grasp.
</span></span><span class=line><span class=cl>    p_GgraspO = [0, 0.12, 0]
</span></span><span class=line><span class=cl>    R_GgraspO = RotationMatrix.MakeXRotation(
</span></span><span class=line><span class=cl>        np.pi / 2.0
</span></span><span class=line><span class=cl>    ) @ RotationMatrix.MakeZRotation(np.pi / 2.0)
</span></span><span class=line><span class=cl>    X_GgraspO = RigidTransform(R_GgraspO, p_GgraspO)
</span></span><span class=line><span class=cl>    X_OGgrasp = X_GgraspO.inverse()
</span></span><span class=line><span class=cl>    # pregrasp is negative y in the gripper frame (see the figure!).
</span></span><span class=line><span class=cl>    X_GgraspGpregrasp = RigidTransform([0, -0.08, 0])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    X_WG[&#34;pick&#34;] = X_WO[&#34;initial&#34;] @ X_OGgrasp
</span></span><span class=line><span class=cl>    X_WG[&#34;prepick&#34;] = X_WG[&#34;pick&#34;] @ X_GgraspGpregrasp
</span></span><span class=line><span class=cl>    X_WG[&#34;place&#34;] = X_WO[&#34;goal&#34;] @ X_OGgrasp
</span></span><span class=line><span class=cl>    X_WG[&#34;preplace&#34;] = X_WG[&#34;place&#34;] @ X_GgraspGpregrasp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # I&#39;ll interpolate a halfway orientation by converting to axis angle and halving the angle.
</span></span><span class=line><span class=cl>    X_GprepickGpreplace = X_WG[&#34;prepick&#34;].inverse() @ X_WG[&#34;preplace&#34;]
</span></span><span class=line><span class=cl>    angle_axis = X_GprepickGpreplace.rotation().ToAngleAxis()
</span></span><span class=line><span class=cl>    X_GprepickGclearance = RigidTransform(
</span></span><span class=line><span class=cl>        AngleAxis(angle=angle_axis.angle() / 2.0, axis=angle_axis.axis()),
</span></span><span class=line><span class=cl>        X_GprepickGpreplace.translation() / 2.0 + np.array([0, -0.3, 0]),
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    X_WG[&#34;clearance&#34;] = X_WG[&#34;prepick&#34;] @ X_GprepickGclearance
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # Now let&#39;s set the timing
</span></span><span class=line><span class=cl>    times = {&#34;initial&#34;: 0}
</span></span><span class=line><span class=cl>    X_GinitialGprepick = X_G[&#34;initial&#34;].inverse() @ X_WG[&#34;prepick&#34;]
</span></span><span class=line><span class=cl>    times[&#34;prepick&#34;] = times[&#34;initial&#34;] + 10.0 * np.linalg.norm(
</span></span><span class=line><span class=cl>        X_GinitialGprepick.translation()
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    # Allow some time for the gripper to close.
</span></span><span class=line><span class=cl>    times[&#34;pick_start&#34;] = times[&#34;prepick&#34;] + 2.0
</span></span><span class=line><span class=cl>    times[&#34;pick_end&#34;] = times[&#34;pick_start&#34;] + 2.0
</span></span><span class=line><span class=cl>    X_WG[&#34;pick_start&#34;] = X_WG[&#34;pick&#34;]
</span></span><span class=line><span class=cl>    X_WG[&#34;pick_end&#34;] = X_WG[&#34;pick&#34;]
</span></span><span class=line><span class=cl>    times[&#34;postpick&#34;] = times[&#34;pick_end&#34;] + 2.0
</span></span><span class=line><span class=cl>    X_WG[&#34;postpick&#34;] = X_WG[&#34;prepick&#34;]
</span></span><span class=line><span class=cl>    time_to_from_clearance = 10.0 * np.linalg.norm(
</span></span><span class=line><span class=cl>        X_GprepickGclearance.translation()
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    times[&#34;clearance&#34;] = times[&#34;postpick&#34;] + time_to_from_clearance
</span></span><span class=line><span class=cl>    times[&#34;preplace&#34;] = times[&#34;clearance&#34;] + time_to_from_clearance
</span></span><span class=line><span class=cl>    times[&#34;place_start&#34;] = times[&#34;preplace&#34;] + 2.0
</span></span><span class=line><span class=cl>    times[&#34;place_end&#34;] = times[&#34;place_start&#34;] + 2.0
</span></span><span class=line><span class=cl>    X_WG[&#34;place_start&#34;] = X_WG[&#34;place&#34;]
</span></span><span class=line><span class=cl>    X_WG[&#34;place_end&#34;] = X_WG[&#34;place&#34;]
</span></span><span class=line><span class=cl>    times[&#34;postplace&#34;] = times[&#34;place_end&#34;] + 2.0
</span></span><span class=line><span class=cl>    X_WG[&#34;postplace&#34;] = X_WG[&#34;preplace&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # combine all the tiem and tracjectories.
</span></span><span class=line><span class=cl>    sample_times = []
</span></span><span class=line><span class=cl>    X_WG_traj = []
</span></span><span class=line><span class=cl>    for name in [
</span></span><span class=line><span class=cl>        &#34;initial&#34;,
</span></span><span class=line><span class=cl>        &#34;prepick&#34;,
</span></span><span class=line><span class=cl>        &#34;pick_start&#34;,
</span></span><span class=line><span class=cl>        &#34;pick_end&#34;,
</span></span><span class=line><span class=cl>        &#34;postpick&#34;,
</span></span><span class=line><span class=cl>        &#34;clearance&#34;,
</span></span><span class=line><span class=cl>        &#34;preplace&#34;,
</span></span><span class=line><span class=cl>        &#34;place_start&#34;,
</span></span><span class=line><span class=cl>        &#34;place_end&#34;,
</span></span><span class=line><span class=cl>        &#34;postplace&#34;,
</span></span><span class=line><span class=cl>    ]:
</span></span><span class=line><span class=cl>        sample_times.append(times[name])
</span></span><span class=line><span class=cl>        X_WG_traj.append(X_WG[name])
</span></span><span class=line><span class=cl>        print(name, X_WG[name].translation())
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # Do a piecewise linear interpolation.
</span></span><span class=line><span class=cl>    traj_position_G = PiecewisePose.MakeLinear(sample_times, X_WG_traj)
</span></span><span class=line><span class=cl>    print(traj_position_G)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # Get the trajectories in velocity though differentiation.
</span></span><span class=line><span class=cl>    traj_velocity_G = traj_position_G.MakeDerivative()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # Now let&#39;s plot the trajectory.
</span></span><span class=line><span class=cl>    if plot:
</span></span><span class=line><span class=cl>        fig, ax = plt.subplots()
</span></span><span class=line><span class=cl>        plot_time = traj_velocity_G.get_segment_times()
</span></span><span class=line><span class=cl>        plot_V_WG = traj_velocity_G.vector_values(plot_time)
</span></span><span class=line><span class=cl>        plt.plot(plot_time, plot_V_WG.T)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        ax.legend()
</span></span><span class=line><span class=cl>        plt.show()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    return X_WG, times, traj_velocity_G
</span></span></code></pre></div><ol start=5><li>Setting up the gripper trajectory.
Since the gripper is a separate entity, we need to set the trajectory for the gripper separately. Here we are using the a <code>zero-order-trajectory</code>, i.e it will be actuated at a distinct time.</li></ol><p>All these time are predetermined and follows the trajectory of the end effector.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # making the gripper trajectory
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def MakeGripperCommandTrajectory(times):
</span></span><span class=line><span class=cl>    opened = np.array([0.107])
</span></span><span class=line><span class=cl>    closed = np.array([0.0])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    traj_wsg_command = PiecewisePolynomial.FirstOrderHold(
</span></span><span class=line><span class=cl>        [times[&#34;initial&#34;], times[&#34;pick_start&#34;]],
</span></span><span class=line><span class=cl>        np.hstack([[opened], [opened]]),
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>    traj_wsg_command.AppendFirstOrderSegment(times[&#34;pick_end&#34;], closed)
</span></span><span class=line><span class=cl>    traj_wsg_command.AppendFirstOrderSegment(times[&#34;place_start&#34;], closed)
</span></span><span class=line><span class=cl>    traj_wsg_command.AppendFirstOrderSegment(times[&#34;place_end&#34;], opened)
</span></span><span class=line><span class=cl>    traj_wsg_command.AppendFirstOrderSegment(times[&#34;postplace&#34;], opened)
</span></span><span class=line><span class=cl>    return traj_wsg_command
</span></span></code></pre></div><ol start=6><li>Add these trajectories to the diagram.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    Position_X, times, vel_trajectory = make_trajectory(X_G, X_O, plot=True)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # gripper position
</span></span><span class=line><span class=cl>    traj_wsg_command = MakeGripperCommandTrajectory(times)
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # add the trajectory to the diagram
</span></span><span class=line><span class=cl>    V_G_source = builder.AddSystem(TrajectorySource(vel_trajectory))
</span></span><span class=line><span class=cl>    V_G_source.set_name(&#34;V_G_source&#34;)
</span></span></code></pre></div><ol start=7><li>Setting up the inverse kinematics controller for the robot.</li></ol><p>For this I using two different methods, one is the pseudo inverse and the other is the qp (quadratic programming).
Both controller are leaf systems, which means I can connect to the diagram as a system.
I will explain the pseudo inverse controller first and then I will explain the qp controller.</p><h3 id=pseudo-inverse-controller>Pseudo inverse controller<a hidden class=anchor aria-hidden=true href=#pseudo-inverse-controller>#</a></h3><p>Initialization in <code>__init__</code>:</p><ul><li>Initialize the leaf super class.</li><li>Store the plant context, this will help get the positions and vel of the robot.</li><li>Get the model instance for the robot.</li><li>Get the body frame and the world frame for the robot.</li><li>Get the start and end joints for the robot, this will help get the jacobian for the robot.</li><li>Set the input port of the leafsystem, this is essentially a input port to our system, in this case we are taking the desired vel from trajectory source.</li><li>In addition to the desired vel, we also need the position of the robot, so we are setting another input port for the position of the robot.</li><li>Set the output port of the leafsystem, this is an output port to our system, in this case we are giving the desired vel to the robot.</li><li>We are also connecting the output port to the function which will calculate the actual output. In my case this will be <code>CalcOutput</code> function.</li></ul><p>CalcOutput function:</p><ul><li>Get the current position of the robot and the desired vel from the input port by using the diagram context.</li><li>I set the plant pose based on the position, then calculate the jacobian of the robot with respoect to the end joint.</li><li>then removing the unwanted joints from the jacobian.</li><li>then I calculate the pseudo inverse of the jacobian and multiply it with the desired vel to get the actual vel.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class PseudoInverseController(LeafSystem):
</span></span><span class=line><span class=cl>    def __init__(self, plant: MultibodyPlant):
</span></span><span class=line><span class=cl>        super().__init__()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # store the plant for the controller use in future
</span></span><span class=line><span class=cl>        self._plant = plant
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the default context for the plant for the differential kinematics
</span></span><span class=line><span class=cl>        self._get_plant_context = plant.CreateDefaultContext()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the model instance for the iiwa
</span></span><span class=line><span class=cl>        self._iiwa = plant.GetModelInstanceByName(&#34;iiwa&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # these two are for views and transformations
</span></span><span class=line><span class=cl>        self._g = plant.GetBodyByName(&#34;body&#34;).body_frame()
</span></span><span class=line><span class=cl>        self._w = plant.world_frame()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the start and end joints
</span></span><span class=line><span class=cl>        self._start_joint = plant.GetJointByName(&#34;iiwa_joint_1&#34;).velocity_start()
</span></span><span class=line><span class=cl>        self._end_joint = plant.GetJointByName(&#34;iiwa_joint_7&#34;).velocity_start()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # start declaring the inputs nad output ports
</span></span><span class=line><span class=cl>        # input port for the desired velocity
</span></span><span class=line><span class=cl>        self.vel_input_port = self.DeclareVectorInputPort(&#34;V_WG&#34;, 6)
</span></span><span class=line><span class=cl>        # input port for the position of the robot
</span></span><span class=line><span class=cl>        self.q_word = self.DeclareVectorInputPort(&#34;iiwa.position&#34;, 7)
</span></span><span class=line><span class=cl>        # output port for the desired velocity
</span></span><span class=line><span class=cl>        self.DeclareVectorOutputPort(&#34;iiwa.velocity&#34;, 7, self.CalcOutput)
</span></span><span class=line><span class=cl>        # this is optional to store the trajectory data.
</span></span><span class=line><span class=cl>        self.save_data = []
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    def CalcOutput(self, context, output):
</span></span><span class=line><span class=cl>        # get the current position of the robot
</span></span><span class=line><span class=cl>        q = self.q_word.Eval(context)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the current velocity of the robot
</span></span><span class=line><span class=cl>        v = self.vel_input_port.Eval(context)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # set the position to the robot. Still not sure why we need to do this.
</span></span><span class=line><span class=cl>        self._plant.SetPositions(self._get_plant_context, self._iiwa, q)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the jacobian of the robot
</span></span><span class=line><span class=cl>        J = self._plant.CalcJacobianSpatialVelocity(
</span></span><span class=line><span class=cl>            self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>        J = J[:, self._start_joint : self._end_joint + 1]
</span></span><span class=line><span class=cl>        v = np.linalg.pinv(J).dot(v)
</span></span><span class=line><span class=cl>        self.save_data.append(v)
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        output.SetFromVector(v)
</span></span></code></pre></div><h3 id=qp-controller>QP controller<a hidden class=anchor aria-hidden=true href=#qp-controller>#</a></h3><p>The next is the qp controller, this is a bit more complicated than the pseudo inverse controller.
Initialization in <code>__init__</code>:</p><ul><li>Initialization is same as the pseudo inverse controller.</li><li>In addition I also initializing a variable which will store the jacobian and the desired vel.</li></ul><p>CalcOutput function:</p><ul><li>Starting part of the function is same as the pseudo inverse controller.</li><li>After I find the jacobian, I solving a quadratic programming problem to find the actual vel, using the drake math program solver <code>Solve</code>.</li><li>I am using the <code>Solve</code> function to solve the mathmatical problem, which is defined in the <code>_define_math_problem</code> function.</li></ul><p>_define_math_problem function:</p><ul><li>This function is used to define the mathmatical problem for the qp solver.</li><li>I am using the <code>MathematicalProgram</code> class to define the problem.</li><li>I add the continous variable to the problem, which is the actual vel. ( here I am 15 variables, because the jacobian is also 6 * 15, there are some useless joints there, I kept it for fun, you can remove it if you want)</li><li>I add the bounding box constraint to the problem, this is to make sure the vel is within the limits.</li><li>I also calculate the error using the following equation $error = J * v - v_{desired}$</li><li>I add the cost to the problem, which is the error dot product with itself ( this make the error quadratic, which is needed for the qp solver)</li><li>I return the problem to the solve.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#TODO Need to make a controller super class in the future
</span></span><span class=line><span class=cl>class QPController(LeafSystem):
</span></span><span class=line><span class=cl>    def __init__(self, plant: MultibodyPlant):
</span></span><span class=line><span class=cl>        super().__init__()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # store the plant for the controller use in future
</span></span><span class=line><span class=cl>        self._plant = plant
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the default context for the plant for the differential kinematics
</span></span><span class=line><span class=cl>        self._get_plant_context = plant.CreateDefaultContext()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the model instance for the iiwa
</span></span><span class=line><span class=cl>        self._iiwa = plant.GetModelInstanceByName(&#34;iiwa&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # these two are for views and transformations
</span></span><span class=line><span class=cl>        self._g = plant.GetBodyByName(&#34;body&#34;).body_frame()
</span></span><span class=line><span class=cl>        self._w = plant.world_frame()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the start and end joints
</span></span><span class=line><span class=cl>        self._start_joint = plant.GetJointByName(&#34;iiwa_joint_1&#34;).velocity_start()
</span></span><span class=line><span class=cl>        self._end_joint = plant.GetJointByName(&#34;iiwa_joint_7&#34;).velocity_start()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # start declaring the inputs nad output ports
</span></span><span class=line><span class=cl>        self.vel_input_port = self.DeclareVectorInputPort(&#34;V_WG&#34;, 6)
</span></span><span class=line><span class=cl>        self.q_word = self.DeclareVectorInputPort(&#34;iiwa.position&#34;, 7)
</span></span><span class=line><span class=cl>        self.DeclareVectorOutputPort(&#34;iiwa.velocity&#34;, 7, self.CalcOutput)
</span></span><span class=line><span class=cl>        self.save_data = [] 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # Initialize the J and x with None
</span></span><span class=line><span class=cl>        self.J = None
</span></span><span class=line><span class=cl>        self.v = None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    def _define_math_problem(self, v_desired: np.ndarray):
</span></span><span class=line><span class=cl>        prog = MathematicalProgram()
</span></span><span class=line><span class=cl>        v = prog.NewContinuousVariables(15, &#34;v&#34;)
</span></span><span class=line><span class=cl>        v_max = 0.5
</span></span><span class=line><span class=cl>        error = self.J @ v - np.array(v_desired)
</span></span><span class=line><span class=cl>        prog.AddBoundingBoxConstraint(-v_max, v_max, v)
</span></span><span class=line><span class=cl>        prog.AddCost(error.dot(error))
</span></span><span class=line><span class=cl>        return prog
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    def CalcOutput(self, context: Context, outputs: SystemOutput) -&gt; None:
</span></span><span class=line><span class=cl>        # get the current position of the robot
</span></span><span class=line><span class=cl>        q = self.q_word.Eval(context)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the current velocity of the robot
</span></span><span class=line><span class=cl>        v = self.vel_input_port.Eval(context)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # set the position to the robot. Still not sure why we need to do this.
</span></span><span class=line><span class=cl>        self._plant.SetPositions(self._get_plant_context, self._iiwa, q)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # get the jacobian of the robot
</span></span><span class=line><span class=cl>        self.J = self._plant.CalcJacobianSpatialVelocity(
</span></span><span class=line><span class=cl>            self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w
</span></span><span class=line><span class=cl>        )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        # print(v.shape, v)
</span></span><span class=line><span class=cl>        result = Solve(self._define_math_problem(v))
</span></span><span class=line><span class=cl>        r = result.GetSolution(v)
</span></span><span class=line><span class=cl>        v = result.get_x_val()[:7]
</span></span><span class=line><span class=cl>        # print(result.get_x_val()[:7], &#34;This is the x val results&#34;)
</span></span><span class=line><span class=cl>        # print(r.shape, r)
</span></span><span class=line><span class=cl>        # v = np.array([print(dir(c[0])) for c in r])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        self.save_data.append(v)
</span></span><span class=line><span class=cl>        # print(v)
</span></span><span class=line><span class=cl>        # print(&#34;v&#34;, v, dir(v), type(v))
</span></span><span class=line><span class=cl>        # print(np.array(v), dir(v), type(v))
</span></span><span class=line><span class=cl>        outputs.SetFromVector(v)
</span></span></code></pre></div><ol start=8><li>Adding the controllers to the diagram.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # add the controller to the diagram
</span></span><span class=line><span class=cl>    controller = builder.AddSystem(PseudoInverseController(plant))
</span></span><span class=line><span class=cl>    # controller = builder.AddSystem(QPController(plant))
</span></span></code></pre></div><ol start=9><li>Add the integrator to the diagram. Since the controller return the vel, we need to integrate it to get the position.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # add the integrator to the diagram
</span></span><span class=line><span class=cl>    integrator = builder.AddSystem(Integrator(7))
</span></span></code></pre></div><ol start=10><li>Make all the connections.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # connections between the systems
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # 1. connect the desired velocity to the controller
</span></span><span class=line><span class=cl>    builder.Connect(V_G_source.get_output_port(), controller.GetInputPort(&#34;V_WG&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # 2. connect the output of the controller to the integrator
</span></span><span class=line><span class=cl>    builder.Connect(controller.get_output_port(), integrator.get_input_port())
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # 3. connect the integrator to the iiwa position
</span></span><span class=line><span class=cl>    builder.Connect(integrator.get_output_port(), station.GetInputPort(&#34;iiwa.position&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # 4. connect the iiwa state to the controller
</span></span><span class=line><span class=cl>    builder.Connect(station.GetOutputPort(&#34;iiwa.position_measured&#34;), controller.GetInputPort(&#34;iiwa.position&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # calcualte connecting the gripper
</span></span><span class=line><span class=cl>    wsg_source = builder.AddSystem(TrajectorySource(traj_wsg_command))
</span></span><span class=line><span class=cl>    wsg_source.set_name(&#34;wsg.command&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # 5. gripper position to the station
</span></span><span class=line><span class=cl>    builder.Connect(wsg_source.get_output_port(), station.GetInputPort(&#34;wsg.position&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    diagram = builder.Build()
</span></span><span class=line><span class=cl>    diagram.set_name(&#34;Testing_pick_and_place&#34;)
</span></span></code></pre></div><ol start=11><li>Visualize the diagram using pydot. I love this part of drake a LOT.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    # visualize the diagram
</span></span><span class=line><span class=cl>    print(&#34;Diagram built&#34;)
</span></span><span class=line><span class=cl>    pydot.graph_from_dot_data( diagram.GetGraphvizString())[0].write_svg(&#34;station_pick_place.svg&#34;)
</span></span></code></pre></div><ol start=12><li>Simulate the system.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    # simulate the diagram
</span></span><span class=line><span class=cl>    simulator = Simulator(diagram)
</span></span><span class=line><span class=cl>    context = simulator.get_mutable_context()
</span></span><span class=line><span class=cl>    station_context = station.GetMyContextFromRoot(context)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    integrator.set_integral_value(integrator.GetMyContextFromRoot(context),
</span></span><span class=line><span class=cl>                                    plant.GetPositions(
</span></span><span class=line><span class=cl>                                        plant.GetMyContextFromRoot(context),
</span></span><span class=line><span class=cl>                                        plant.GetModelInstanceByName(&#34;iiwa&#34;),
</span></span><span class=line><span class=cl>                                    ),
</span></span><span class=line><span class=cl>    )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    diagram.ForcedPublish(context)
</span></span><span class=line><span class=cl>    meshcat.StartRecording(set_visualizations_while_recording=True)
</span></span><span class=line><span class=cl>    simulator.AdvanceTo(vel_trajectory.end_time())
</span></span><span class=line><span class=cl>    meshcat.StopRecording()
</span></span><span class=line><span class=cl>    meshcat.PublishRecording()
</span></span></code></pre></div><ol start=13><li>Plot the results.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    plt.plot(np.array(controller.save_data).reshape(-1,7))
</span></span><span class=line><span class=cl>    plt.show()
</span></span></code></pre></div><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/rtCUpqlqp20?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>I tried embedding video, but hugo is not letting me, so here is the youtube video: <a href=https://youtu.be/rtCUpqlqp20>https://youtu.be/rtCUpqlqp20</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/drake/>Drake</a></li><li><a href=http://localhost:1313/tags/manipulation/>Manipulation</a></li><li><a href=http://localhost:1313/tags/robotics/>Robotics</a></li><li><a href=http://localhost:1313/tags/introduction/>Introduction</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Pk blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>