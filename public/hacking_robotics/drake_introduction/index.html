<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Drake setup and introduction to IK using pseudo inverse and quadratic programming | Pk blog</title>
<meta name=keywords content="Drake,Manipulation,Robotics,Introduction">
<meta name=description content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.">
<meta name=author content="Me">
<link rel=canonical href=https://prakyathk.com/hacking_robotics/drake_introduction/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style>
<link rel=icon href=https://prakyathk.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://prakyathk.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://prakyathk.com/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://prakyathk.com/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://prakyathk.com/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Drake setup and introduction to IK using pseudo inverse and quadratic programming">
<meta property="og:description" content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://prakyathk.com/hacking_robotics/drake_introduction/"><meta property="og:image" content="https://prakyathk.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="hacking_robotics">
<meta property="article:published_time" content="2023-10-15T18:49:58-05:00">
<meta property="article:modified_time" content="2023-10-15T18:49:58-05:00"><meta property="og:site_name" content="PK's Blog">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://prakyathk.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Drake setup and introduction to IK using pseudo inverse and quadratic programming">
<meta name=twitter:description content="Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.
Setup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Hacking_robotics","item":"https://prakyathk.com/hacking_robotics/"},{"@type":"ListItem","position":2,"name":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","item":"https://prakyathk.com/hacking_robotics/drake_introduction/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","name":"Drake setup and introduction to IK using pseudo inverse and quadratic programming","description":"Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.\nSetup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.","keywords":["Drake","Manipulation","Robotics","Introduction"],"articleBody":"Introduction to Drake Drake is a C++ toolbox started by Russ Tedrake and his group at MIT. It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.\nSetup for manipulation In this project I am borrowing most of the work from the Drake manipulation repository, which is used to teach the manipulators course at MIT. Here are the course documents: manipulation and Manipulation youtube playlist from last semester.\nThis document will run the simple pick \u0026 place example from the course and also add some of my own functions to switch the solving type.\nSetup for this tutorials are as follows:  clone the repository:  git clone https://github.com/Prakyathkantharaju/Hacking-robotics Setup python env Install python version of drake.  pip install pydrake In the robotics directory, clone the manipulation repository, I am not sure if this is also a pip installable package but I prefer to clone the repository as you can edit yaml file to add your own robot.  git clone https://github.com/RussTedrake/manipulation I will be using loading and viusalizations tools from the repository, I will be adding the location of this repository to the python path in the next step.\nimport sys sys.path.append('../manipulation') Running the pick and place example The full python file is located in robotics/drake/pick_plane_inverse_qp.py\nI will break the code into sections and explain each section here.\n Importing the necessary libraries NOTE: I have the manipulator library in the robotics/drake/manipulation directory, so I am adding that to the python path. If you have installed the manipulation library as a pip package, you can skip this step. If you have cloned the manipulation repository, you can add the path to the python path.  # loading the python libraries import numpy as np import matplotlib.pyplot as plt import pydot # loading the drake variables from pydrake.all import ( AddMultibodyPlantSceneGraph, AngleAxis, Context, DiagramBuilder, Integrator, JacobianWrtVariable, LeafSystem, MeshcatVisualizer, MultibodyPlant, MultibodyPositionToGeometryPose, Parser, PiecewisePolynomial, PiecewisePose, Quaternion, Rgba, RigidTransform, RotationMatrix, SceneGraph, Simulator, StartMeshcat, SystemOutput, TrajectorySource, MathematicalProgram, Solve, ) import sys sys.path.append('manipulation/') from manipulation.scenarios import AddMultibodyPlantSceneGraph from manipulation.station import MakeHardwareStation, load_scenario Loading the robot and the environment Here we are loading the meshcat server, which is a visualization tool for drake. After that we are loading the scenario, which is a yaml file that has the robot and the environment information. We use the diagram builder to add the scenario to the diagram.  # start the meshcat server meshcat = StartMeshcat() # scenario scenario = \\ \"\"\" directives: - add_directives: file: package://manipulation/clutter.dmd.yaml - add_model: name: foam_brick file: package://manipulation/hydro/061_foam_brick.sdf model_drivers: iiwa: !IiwaDriver hand_model_name: wsg wsg: !SchunkWsgDriver {} \"\"\" # start with some blank diagram builder = DiagramBuilder() # loading the scenriao using the yaml string above. scenario = load_scenario(data=scenario) # adding scenario to the diagram, the scenario has two parts, iiwa and the wsg. you can visualize this in the diagram. station = builder.AddSystem(MakeHardwareStation( scenario=scenario, meshcat=meshcat)) Setting the default pose for the robot. Here are getting the plant for the robot and setting the default pose for the elements in the diagram.  # get the plant plant = station.GetSubsystemByName(\"plant\") # set the pose for the body plant.SetDefaultFreeBodyPose(plant.GetBodyByName(\"base_link\"), RigidTransform(RotationMatrix.MakeZRotation(np.pi/2), [0,-0.6,0])) # set the pose for the gripper get_context = station.CreateDefaultContext() plant_context = plant.GetMyContextFromRoot(get_context) Generating the trajectories for the robot. First we have set the initial and final pose for the robot. This is predetermined, I did not change it. Both in the body frame and the world frame, here is the code for that:  # making trajectory X_G = {\"initial\": plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(\"body\")), \"goal\": RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame X_O = {\"initial\": plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(\"base_link\")), # x with respect to the body frame \"goal\": RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame Now using this start and end point, we make the trajectory for the end effector for the robot here is the code for that. So this is a big function, which I intend to break down into smaller functions later. But let me go step by step what is happening here.\n First I use the start and end point and get the parts of the trajectory that are predetermined, like the pregrasp, grasp, preplace, place, etc. Then we set the time between the trajectory points, this is also predetermined, I did not change it. After this I use the piecewise linear function to interpolate the trajectory between the points. Then I differentiate the trajectory to get the velocity trajectory. Then I plot the trajectory, this is just for visualization if the plot flag is set to True.  # making the trajectory for the end effector def make_trajectory(X_WG: dict, X_WO: dict, plot:bool =True): \"\"\" Takes a partial specification with X_G[\"initial\"] and X_O[\"initial\"] and X_0[\"goal\"], and returns a X_G and times with all of the pick and place frames populated. \"\"\" X_G = { \"initial\": RigidTransform(RotationMatrix.MakeXRotation(-np.pi / 2.0), [0, -0.25, 0.25]) } # TODO(prakyath) THIS IS COPIED FROM THE PICK NOTEBOOK, BUT YOU'LL NEED TO MODIFY IT FOR WITH RL LATER. # Define (again) the gripper pose relative to the object when in grasp. p_GgraspO = [0, 0.12, 0] R_GgraspO = RotationMatrix.MakeXRotation( np.pi / 2.0 ) @ RotationMatrix.MakeZRotation(np.pi / 2.0) X_GgraspO = RigidTransform(R_GgraspO, p_GgraspO) X_OGgrasp = X_GgraspO.inverse() # pregrasp is negative y in the gripper frame (see the figure!). X_GgraspGpregrasp = RigidTransform([0, -0.08, 0]) X_WG[\"pick\"] = X_WO[\"initial\"] @ X_OGgrasp X_WG[\"prepick\"] = X_WG[\"pick\"] @ X_GgraspGpregrasp X_WG[\"place\"] = X_WO[\"goal\"] @ X_OGgrasp X_WG[\"preplace\"] = X_WG[\"place\"] @ X_GgraspGpregrasp # I'll interpolate a halfway orientation by converting to axis angle and halving the angle. X_GprepickGpreplace = X_WG[\"prepick\"].inverse() @ X_WG[\"preplace\"] angle_axis = X_GprepickGpreplace.rotation().ToAngleAxis() X_GprepickGclearance = RigidTransform( AngleAxis(angle=angle_axis.angle() / 2.0, axis=angle_axis.axis()), X_GprepickGpreplace.translation() / 2.0 + np.array([0, -0.3, 0]), ) X_WG[\"clearance\"] = X_WG[\"prepick\"] @ X_GprepickGclearance # Now let's set the timing times = {\"initial\": 0} X_GinitialGprepick = X_G[\"initial\"].inverse() @ X_WG[\"prepick\"] times[\"prepick\"] = times[\"initial\"] + 10.0 * np.linalg.norm( X_GinitialGprepick.translation() ) # Allow some time for the gripper to close. times[\"pick_start\"] = times[\"prepick\"] + 2.0 times[\"pick_end\"] = times[\"pick_start\"] + 2.0 X_WG[\"pick_start\"] = X_WG[\"pick\"] X_WG[\"pick_end\"] = X_WG[\"pick\"] times[\"postpick\"] = times[\"pick_end\"] + 2.0 X_WG[\"postpick\"] = X_WG[\"prepick\"] time_to_from_clearance = 10.0 * np.linalg.norm( X_GprepickGclearance.translation() ) times[\"clearance\"] = times[\"postpick\"] + time_to_from_clearance times[\"preplace\"] = times[\"clearance\"] + time_to_from_clearance times[\"place_start\"] = times[\"preplace\"] + 2.0 times[\"place_end\"] = times[\"place_start\"] + 2.0 X_WG[\"place_start\"] = X_WG[\"place\"] X_WG[\"place_end\"] = X_WG[\"place\"] times[\"postplace\"] = times[\"place_end\"] + 2.0 X_WG[\"postplace\"] = X_WG[\"preplace\"] # combine all the tiem and tracjectories. sample_times = [] X_WG_traj = [] for name in [ \"initial\", \"prepick\", \"pick_start\", \"pick_end\", \"postpick\", \"clearance\", \"preplace\", \"place_start\", \"place_end\", \"postplace\", ]: sample_times.append(times[name]) X_WG_traj.append(X_WG[name]) print(name, X_WG[name].translation()) # Do a piecewise linear interpolation. traj_position_G = PiecewisePose.MakeLinear(sample_times, X_WG_traj) print(traj_position_G) # Get the trajectories in velocity though differentiation. traj_velocity_G = traj_position_G.MakeDerivative() # Now let's plot the trajectory. if plot: fig, ax = plt.subplots() plot_time = traj_velocity_G.get_segment_times() plot_V_WG = traj_velocity_G.vector_values(plot_time) plt.plot(plot_time, plot_V_WG.T) ax.legend() plt.show() return X_WG, times, traj_velocity_G Setting up the gripper trajectory. Since the gripper is a separate entity, we need to set the trajectory for the gripper separately. Here we are using the a zero-order-trajectory, i.e it will be actuated at a distinct time.  All these time are predetermined and follows the trajectory of the end effector.\n# making the gripper trajectory def MakeGripperCommandTrajectory(times): opened = np.array([0.107]) closed = np.array([0.0]) traj_wsg_command = PiecewisePolynomial.FirstOrderHold( [times[\"initial\"], times[\"pick_start\"]], np.hstack([[opened], [opened]]), ) traj_wsg_command.AppendFirstOrderSegment(times[\"pick_end\"], closed) traj_wsg_command.AppendFirstOrderSegment(times[\"place_start\"], closed) traj_wsg_command.AppendFirstOrderSegment(times[\"place_end\"], opened) traj_wsg_command.AppendFirstOrderSegment(times[\"postplace\"], opened) return traj_wsg_command Add these trajectories to the diagram.  Position_X, times, vel_trajectory = make_trajectory(X_G, X_O, plot=True) # gripper position traj_wsg_command = MakeGripperCommandTrajectory(times) # add the trajectory to the diagram V_G_source = builder.AddSystem(TrajectorySource(vel_trajectory)) V_G_source.set_name(\"V_G_source\") Setting up the inverse kinematics controller for the robot.  For this I using two different methods, one is the pseudo inverse and the other is the qp (quadratic programming). Both controller are leaf systems, which means I can connect to the diagram as a system. I will explain the pseudo inverse controller first and then I will explain the qp controller.\nPseudo inverse controller Initialization in __init__:\n Initialize the leaf super class. Store the plant context, this will help get the positions and vel of the robot. Get the model instance for the robot. Get the body frame and the world frame for the robot. Get the start and end joints for the robot, this will help get the jacobian for the robot. Set the input port of the leafsystem, this is essentially a input port to our system, in this case we are taking the desired vel from trajectory source. In addition to the desired vel, we also need the position of the robot, so we are setting another input port for the position of the robot. Set the output port of the leafsystem, this is an output port to our system, in this case we are giving the desired vel to the robot. We are also connecting the output port to the function which will calculate the actual output. In my case this will be CalcOutput function.  CalcOutput function:\n Get the current position of the robot and the desired vel from the input port by using the diagram context. I set the plant pose based on the position, then calculate the jacobian of the robot with respoect to the end joint. then removing the unwanted joints from the jacobian. then I calculate the pseudo inverse of the jacobian and multiply it with the desired vel to get the actual vel.  class PseudoInverseController(LeafSystem): def __init__(self, plant: MultibodyPlant): super().__init__() # store the plant for the controller use in future self._plant = plant # get the default context for the plant for the differential kinematics self._get_plant_context = plant.CreateDefaultContext() # get the model instance for the iiwa self._iiwa = plant.GetModelInstanceByName(\"iiwa\") # these two are for views and transformations self._g = plant.GetBodyByName(\"body\").body_frame() self._w = plant.world_frame() # get the start and end joints self._start_joint = plant.GetJointByName(\"iiwa_joint_1\").velocity_start() self._end_joint = plant.GetJointByName(\"iiwa_joint_7\").velocity_start() # start declaring the inputs nad output ports # input port for the desired velocity self.vel_input_port = self.DeclareVectorInputPort(\"V_WG\", 6) # input port for the position of the robot self.q_word = self.DeclareVectorInputPort(\"iiwa.position\", 7) # output port for the desired velocity self.DeclareVectorOutputPort(\"iiwa.velocity\", 7, self.CalcOutput) # this is optional to store the trajectory data. self.save_data = [] def CalcOutput(self, context, output): # get the current position of the robot q = self.q_word.Eval(context) # get the current velocity of the robot v = self.vel_input_port.Eval(context) # set the position to the robot. Still not sure why we need to do this. self._plant.SetPositions(self._get_plant_context, self._iiwa, q) # get the jacobian of the robot J = self._plant.CalcJacobianSpatialVelocity( self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w ) J = J[:, self._start_joint : self._end_joint + 1] v = np.linalg.pinv(J).dot(v) self.save_data.append(v) output.SetFromVector(v) QP controller The next is the qp controller, this is a bit more complicated than the pseudo inverse controller. Initialization in __init__:\n Initialization is same as the pseudo inverse controller. In addition I also initializing a variable which will store the jacobian and the desired vel.  CalcOutput function:\n Starting part of the function is same as the pseudo inverse controller. After I find the jacobian, I solving a quadratic programming problem to find the actual vel, using the drake math program solver Solve. I am using the Solve function to solve the mathmatical problem, which is defined in the _define_math_problem function.  _define_math_problem function:\n This function is used to define the mathmatical problem for the qp solver. I am using the MathematicalProgram class to define the problem. I add the continous variable to the problem, which is the actual vel. ( here I am 15 variables, because the jacobian is also 6 * 15, there are some useless joints there, I kept it for fun, you can remove it if you want) I add the bounding box constraint to the problem, this is to make sure the vel is within the limits. I also calculate the error using the following equation $error = J * v - v_{desired}$ I add the cost to the problem, which is the error dot product with itself ( this make the error quadratic, which is needed for the qp solver) I return the problem to the solve.  #TODO Need to make a controller super class in the future class QPController(LeafSystem): def __init__(self, plant: MultibodyPlant): super().__init__() # store the plant for the controller use in future self._plant = plant # get the default context for the plant for the differential kinematics self._get_plant_context = plant.CreateDefaultContext() # get the model instance for the iiwa self._iiwa = plant.GetModelInstanceByName(\"iiwa\") # these two are for views and transformations self._g = plant.GetBodyByName(\"body\").body_frame() self._w = plant.world_frame() # get the start and end joints self._start_joint = plant.GetJointByName(\"iiwa_joint_1\").velocity_start() self._end_joint = plant.GetJointByName(\"iiwa_joint_7\").velocity_start() # start declaring the inputs nad output ports self.vel_input_port = self.DeclareVectorInputPort(\"V_WG\", 6) self.q_word = self.DeclareVectorInputPort(\"iiwa.position\", 7) self.DeclareVectorOutputPort(\"iiwa.velocity\", 7, self.CalcOutput) self.save_data = [] # Initialize the J and x with None self.J = None self.v = None def _define_math_problem(self, v_desired: np.ndarray): prog = MathematicalProgram() v = prog.NewContinuousVariables(15, \"v\") v_max = 0.5 error = self.J @ v - np.array(v_desired) prog.AddBoundingBoxConstraint(-v_max, v_max, v) prog.AddCost(error.dot(error)) return prog def CalcOutput(self, context: Context, outputs: SystemOutput) - None: # get the current position of the robot q = self.q_word.Eval(context) # get the current velocity of the robot v = self.vel_input_port.Eval(context) # set the position to the robot. Still not sure why we need to do this. self._plant.SetPositions(self._get_plant_context, self._iiwa, q) # get the jacobian of the robot self.J = self._plant.CalcJacobianSpatialVelocity( self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w ) # print(v.shape, v) result = Solve(self._define_math_problem(v)) r = result.GetSolution(v) v = result.get_x_val()[:7] # print(result.get_x_val()[:7], \"This is the x val results\") # print(r.shape, r) # v = np.array([print(dir(c[0])) for c in r]) self.save_data.append(v) # print(v) # print(\"v\", v, dir(v), type(v)) # print(np.array(v), dir(v), type(v)) outputs.SetFromVector(v) Adding the controllers to the diagram.  # add the controller to the diagram controller = builder.AddSystem(PseudoInverseController(plant)) # controller = builder.AddSystem(QPController(plant)) Add the integrator to the diagram. Since the controller return the vel, we need to integrate it to get the position.  # add the integrator to the diagram integrator = builder.AddSystem(Integrator(7)) Make all the connections.  # connections between the systems # 1. connect the desired velocity to the controller builder.Connect(V_G_source.get_output_port(), controller.GetInputPort(\"V_WG\")) # 2. connect the output of the controller to the integrator builder.Connect(controller.get_output_port(), integrator.get_input_port()) # 3. connect the integrator to the iiwa position builder.Connect(integrator.get_output_port(), station.GetInputPort(\"iiwa.position\")) # 4. connect the iiwa state to the controller builder.Connect(station.GetOutputPort(\"iiwa.position_measured\"), controller.GetInputPort(\"iiwa.position\")) # calcualte connecting the gripper wsg_source = builder.AddSystem(TrajectorySource(traj_wsg_command)) wsg_source.set_name(\"wsg.command\") # 5. gripper position to the station builder.Connect(wsg_source.get_output_port(), station.GetInputPort(\"wsg.position\")) diagram = builder.Build() diagram.set_name(\"Testing_pick_and_place\") Visualize the diagram using pydot. I love this part of drake a LOT.  # visualize the diagram print(\"Diagram built\") pydot.graph_from_dot_data( diagram.GetGraphvizString())[0].write_svg(\"station_pick_place.svg\") Simulate the system.  # simulate the diagram simulator = Simulator(diagram) context = simulator.get_mutable_context() station_context = station.GetMyContextFromRoot(context) integrator.set_integral_value(integrator.GetMyContextFromRoot(context), plant.GetPositions( plant.GetMyContextFromRoot(context), plant.GetModelInstanceByName(\"iiwa\"), ), ) diagram.ForcedPublish(context) meshcat.StartRecording(set_visualizations_while_recording=True) simulator.AdvanceTo(vel_trajectory.end_time()) meshcat.StopRecording() meshcat.PublishRecording() Plot the results.  plt.plot(np.array(controller.save_data).reshape(-1,7)) plt.show() Results   I tried embedding video, but hugo is not letting me, so here is the youtube video: https://youtu.be/rtCUpqlqp20\n","wordCount":"2444","inLanguage":"en","datePublished":"2023-10-15T18:49:58-05:00","dateModified":"2023-10-15T18:49:58-05:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://prakyathk.com/hacking_robotics/drake_introduction/"},"publisher":{"@type":"Organization","name":"Pk blog","logo":{"@type":"ImageObject","url":"https://prakyathk.com/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://prakyathk.com/ accesskey=h title="Prakyath Kantharaju's Blog (Alt + H)">
<img src=https://prakyathk.com/apple-touch-icon.png alt aria-label=logo height=35>Prakyath Kantharaju's Blog</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://prakyathk.com/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://prakyathk.com/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://github.com/prakyathkantharaju title=github.com>
<span>github.com</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg>
</a>
</li>
<li>
<a href=https://prakyathk.com/projects/ title=projects>
<span>projects</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://prakyathk.com/>Home</a>&nbsp;»&nbsp;<a href=https://prakyathk.com/hacking_robotics/>Hacking_robotics</a></div>
<h1 class="post-title entry-hint-parent">
Drake setup and introduction to IK using pseudo inverse and quadratic programming
</h1>
<div class=post-meta><span title="2023-10-15 18:49:58 -0500 CDT">October 15, 2023</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2444 words&nbsp;·&nbsp;Me
</div>
</header>
<div class=post-content><h1 id=introduction-to-drake>Introduction to Drake<a hidden class=anchor aria-hidden=true href=#introduction-to-drake>#</a></h1>
<p>Drake is a C++ toolbox started by Russ Tedrake and his group at MIT.
It is a collection of libraries for efficient rigid body dynamics computations and constraint-based multibody dynamics, mainly used for manipulation planning and control.</p>
<h1 id=setup-for-manipulation>Setup for manipulation<a hidden class=anchor aria-hidden=true href=#setup-for-manipulation>#</a></h1>
<p>In this project I am borrowing most of the work from the <a href=https://github.com/RussTedrake/manipulation>Drake manipulation repository</a>, which is used to teach the manipulators course at MIT.
Here are the course documents: <a href=http://manipulation.csail.mit.edu/>manipulation</a> and <a href="https://youtube.com/playlist?list=PLkx8KyIQkMfUSDs2hvTWzaq-cxGl8Ha69&si=xwgcVbpWYG-cGHDa">Manipulation youtube playlist from last semester</a>.</p>
<p>This document will run the simple pick & place example from the course and also add some of my own functions to switch the solving type.</p>
<h2 id=setup-for-this-tutorials-are-as-follows>Setup for this tutorials are as follows:<a hidden class=anchor aria-hidden=true href=#setup-for-this-tutorials-are-as-follows>#</a></h2>
<ol>
<li>clone the repository:</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>git clone https://github.com/Prakyathkantharaju/Hacking-robotics
</code></pre></div><ol start=2>
<li>Setup python env
Install python version of drake.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>pip install pydrake
</code></pre></div><ol start=3>
<li>In the robotics directory, clone the manipulation repository, I am not sure if this is also a pip installable package but I prefer to clone the repository as you can edit yaml file to add your own robot.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>git clone https://github.com/RussTedrake/manipulation
</code></pre></div><p>I will be using loading and viusalizations tools from the repository, I will be adding the location of this repository to the python path in the next step.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>import sys
sys.path.append(&#39;../manipulation&#39;)
</code></pre></div><h2 id=running-the-pick-and-place-example>Running the pick and place example<a hidden class=anchor aria-hidden=true href=#running-the-pick-and-place-example>#</a></h2>
<p>The full python file is located in <code>robotics/drake/pick_plane_inverse_qp.py</code></p>
<p>I will break the code into sections and explain each section here.</p>
<ol>
<li>Importing the necessary libraries
NOTE: I have the manipulator library in the robotics/drake/manipulation directory, so I am adding that to the python path. If you have installed the manipulation library as a pip package, you can skip this step. If you have cloned the manipulation repository, you can add the path to the python path.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback># loading the python libraries
import numpy as np
import matplotlib.pyplot as plt
import pydot

# loading the drake variables
from pydrake.all import (
    AddMultibodyPlantSceneGraph,
    AngleAxis,
    Context,
    DiagramBuilder,
    Integrator,
    JacobianWrtVariable,
    LeafSystem,
    MeshcatVisualizer,
    MultibodyPlant,
    MultibodyPositionToGeometryPose,
    Parser,
    PiecewisePolynomial,
    PiecewisePose,
    Quaternion,
    Rgba,
    RigidTransform,
    RotationMatrix,
    SceneGraph,
    Simulator,
    StartMeshcat,
    SystemOutput,
    TrajectorySource,
    MathematicalProgram,
    Solve,
)

import sys
sys.path.append(&#39;manipulation/&#39;)

from manipulation.scenarios import AddMultibodyPlantSceneGraph
from manipulation.station import MakeHardwareStation, load_scenario
</code></pre></div><ol start=2>
<li>Loading the robot and the environment
Here we are loading the meshcat server, which is a visualization tool for drake.
After that we are loading the scenario, which is a yaml file that has the robot and the environment information.
We use the diagram builder to add the scenario to the diagram.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # start the meshcat server
    meshcat = StartMeshcat()


    # scenario
    scenario = \
    &#34;&#34;&#34;
    directives:
    - add_directives:
        file: package://manipulation/clutter.dmd.yaml
    - add_model:
        name: foam_brick
        file: package://manipulation/hydro/061_foam_brick.sdf
    model_drivers:
        iiwa: !IiwaDriver
            hand_model_name: wsg
        wsg: !SchunkWsgDriver {}
    &#34;&#34;&#34;
    # start with some blank diagram
    builder = DiagramBuilder()

    # loading the scenriao using the yaml string above.
    scenario = load_scenario(data=scenario)

    # adding scenario to the diagram, the scenario has two parts, iiwa and the wsg. you can visualize this in the diagram.
    station = builder.AddSystem(MakeHardwareStation(
        scenario=scenario, meshcat=meshcat))
</code></pre></div><ol start=3>
<li>Setting the default pose for the robot.
Here are getting the plant for the robot and setting the default pose for the elements in the diagram.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # get the plant
    plant = station.GetSubsystemByName(&#34;plant&#34;)
    # set the pose for the body
    plant.SetDefaultFreeBodyPose(plant.GetBodyByName(&#34;base_link&#34;), 
                                 RigidTransform(RotationMatrix.MakeZRotation(np.pi/2), [0,-0.6,0]))


    # set the pose for the gripper 
    get_context = station.CreateDefaultContext()
    plant_context = plant.GetMyContextFromRoot(get_context)
</code></pre></div><ol start=4>
<li>Generating the trajectories for the robot.
First we have set the initial and final pose for the robot.
This is predetermined, I did not change it.
Both in the body frame and the world frame, here is the code for that:</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # making trajectory
    X_G = {&#34;initial&#34;: plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(&#34;body&#34;)),
           &#34;goal&#34;: RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame
    X_O = {&#34;initial&#34;: plant.EvalBodyPoseInWorld(plant_context, plant.GetBodyByName(&#34;base_link&#34;)), # x with respect to the body frame
           &#34;goal&#34;: RigidTransform(RotationMatrix.MakeZRotation(np.pi), [0.5, 0, 0.0])} # x with respect to the world frame
</code></pre></div><p>Now using this start and end point, we make the trajectory for the end effector for the robot here is the code for that.
So this is a big function, which I intend to break down into smaller functions later. But let me go step by step what is happening here.</p>
<ul>
<li>First I use the start and end point and get the parts of the trajectory that are predetermined, like the pregrasp, grasp, preplace, place, etc.</li>
<li>Then we set the time between the trajectory points, this is also predetermined, I did not change it.</li>
<li>After this I use the piecewise linear function to interpolate the trajectory between the points.</li>
<li>Then I differentiate the trajectory to get the velocity trajectory.</li>
<li>Then I plot the trajectory, this is just for visualization if the <code>plot</code> flag is set to <code>True</code>.</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # making the trajectory for the end effector
def make_trajectory(X_WG: dict, X_WO: dict, plot:bool =True):
    &#34;&#34;&#34;
    Takes a partial specification with X_G[&#34;initial&#34;] and X_O[&#34;initial&#34;] and
    X_0[&#34;goal&#34;], and returns a X_G and times with all of the pick and place
    frames populated.
    &#34;&#34;&#34;
    X_G = { &#34;initial&#34;: RigidTransform(RotationMatrix.MakeXRotation(-np.pi / 2.0), [0, -0.25, 0.25]) }

    # TODO(prakyath) THIS IS COPIED FROM THE PICK NOTEBOOK, BUT YOU&#39;LL NEED TO MODIFY IT FOR WITH RL LATER.
    # Define (again) the gripper pose relative to the object when in grasp.
    p_GgraspO = [0, 0.12, 0]
    R_GgraspO = RotationMatrix.MakeXRotation(
        np.pi / 2.0
    ) @ RotationMatrix.MakeZRotation(np.pi / 2.0)
    X_GgraspO = RigidTransform(R_GgraspO, p_GgraspO)
    X_OGgrasp = X_GgraspO.inverse()
    # pregrasp is negative y in the gripper frame (see the figure!).
    X_GgraspGpregrasp = RigidTransform([0, -0.08, 0])

    X_WG[&#34;pick&#34;] = X_WO[&#34;initial&#34;] @ X_OGgrasp
    X_WG[&#34;prepick&#34;] = X_WG[&#34;pick&#34;] @ X_GgraspGpregrasp
    X_WG[&#34;place&#34;] = X_WO[&#34;goal&#34;] @ X_OGgrasp
    X_WG[&#34;preplace&#34;] = X_WG[&#34;place&#34;] @ X_GgraspGpregrasp

    # I&#39;ll interpolate a halfway orientation by converting to axis angle and halving the angle.
    X_GprepickGpreplace = X_WG[&#34;prepick&#34;].inverse() @ X_WG[&#34;preplace&#34;]
    angle_axis = X_GprepickGpreplace.rotation().ToAngleAxis()
    X_GprepickGclearance = RigidTransform(
        AngleAxis(angle=angle_axis.angle() / 2.0, axis=angle_axis.axis()),
        X_GprepickGpreplace.translation() / 2.0 + np.array([0, -0.3, 0]),
    )
    X_WG[&#34;clearance&#34;] = X_WG[&#34;prepick&#34;] @ X_GprepickGclearance

    # Now let&#39;s set the timing
    times = {&#34;initial&#34;: 0}
    X_GinitialGprepick = X_G[&#34;initial&#34;].inverse() @ X_WG[&#34;prepick&#34;]
    times[&#34;prepick&#34;] = times[&#34;initial&#34;] + 10.0 * np.linalg.norm(
        X_GinitialGprepick.translation()
    )
    # Allow some time for the gripper to close.
    times[&#34;pick_start&#34;] = times[&#34;prepick&#34;] + 2.0
    times[&#34;pick_end&#34;] = times[&#34;pick_start&#34;] + 2.0
    X_WG[&#34;pick_start&#34;] = X_WG[&#34;pick&#34;]
    X_WG[&#34;pick_end&#34;] = X_WG[&#34;pick&#34;]
    times[&#34;postpick&#34;] = times[&#34;pick_end&#34;] + 2.0
    X_WG[&#34;postpick&#34;] = X_WG[&#34;prepick&#34;]
    time_to_from_clearance = 10.0 * np.linalg.norm(
        X_GprepickGclearance.translation()
    )
    times[&#34;clearance&#34;] = times[&#34;postpick&#34;] + time_to_from_clearance
    times[&#34;preplace&#34;] = times[&#34;clearance&#34;] + time_to_from_clearance
    times[&#34;place_start&#34;] = times[&#34;preplace&#34;] + 2.0
    times[&#34;place_end&#34;] = times[&#34;place_start&#34;] + 2.0
    X_WG[&#34;place_start&#34;] = X_WG[&#34;place&#34;]
    X_WG[&#34;place_end&#34;] = X_WG[&#34;place&#34;]
    times[&#34;postplace&#34;] = times[&#34;place_end&#34;] + 2.0
    X_WG[&#34;postplace&#34;] = X_WG[&#34;preplace&#34;]


    # combine all the tiem and tracjectories.
    sample_times = []
    X_WG_traj = []
    for name in [
        &#34;initial&#34;,
        &#34;prepick&#34;,
        &#34;pick_start&#34;,
        &#34;pick_end&#34;,
        &#34;postpick&#34;,
        &#34;clearance&#34;,
        &#34;preplace&#34;,
        &#34;place_start&#34;,
        &#34;place_end&#34;,
        &#34;postplace&#34;,
    ]:
        sample_times.append(times[name])
        X_WG_traj.append(X_WG[name])
        print(name, X_WG[name].translation())

    # Do a piecewise linear interpolation.
    traj_position_G = PiecewisePose.MakeLinear(sample_times, X_WG_traj)
    print(traj_position_G)


    # Get the trajectories in velocity though differentiation.
    traj_velocity_G = traj_position_G.MakeDerivative()

    # Now let&#39;s plot the trajectory.
    if plot:
        fig, ax = plt.subplots()
        plot_time = traj_velocity_G.get_segment_times()
        plot_V_WG = traj_velocity_G.vector_values(plot_time)
        plt.plot(plot_time, plot_V_WG.T)

        ax.legend()
        plt.show()

    return X_WG, times, traj_velocity_G
</code></pre></div><ol start=5>
<li>Setting up the gripper trajectory.
Since the gripper is a separate entity, we need to set the trajectory for the gripper separately. Here we are using the a <code>zero-order-trajectory</code>, i.e it will be actuated at a distinct time.</li>
</ol>
<p>All these time are predetermined and follows the trajectory of the end effector.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # making the gripper trajectory

def MakeGripperCommandTrajectory(times):
    opened = np.array([0.107])
    closed = np.array([0.0])

    traj_wsg_command = PiecewisePolynomial.FirstOrderHold(
        [times[&#34;initial&#34;], times[&#34;pick_start&#34;]],
        np.hstack([[opened], [opened]]),
    )
    traj_wsg_command.AppendFirstOrderSegment(times[&#34;pick_end&#34;], closed)
    traj_wsg_command.AppendFirstOrderSegment(times[&#34;place_start&#34;], closed)
    traj_wsg_command.AppendFirstOrderSegment(times[&#34;place_end&#34;], opened)
    traj_wsg_command.AppendFirstOrderSegment(times[&#34;postplace&#34;], opened)
    return traj_wsg_command
</code></pre></div><ol start=6>
<li>Add these trajectories to the diagram.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    Position_X, times, vel_trajectory = make_trajectory(X_G, X_O, plot=True)

    # gripper position
    traj_wsg_command = MakeGripperCommandTrajectory(times)
    

    # add the trajectory to the diagram
    V_G_source = builder.AddSystem(TrajectorySource(vel_trajectory))
    V_G_source.set_name(&#34;V_G_source&#34;)
</code></pre></div><ol start=7>
<li>Setting up the inverse kinematics controller for the robot.</li>
</ol>
<p>For this I using two different methods, one is the pseudo inverse and the other is the qp (quadratic programming).
Both controller are leaf systems, which means I can connect to the diagram as a system.
I will explain the pseudo inverse controller first and then I will explain the qp controller.</p>
<h3 id=pseudo-inverse-controller>Pseudo inverse controller<a hidden class=anchor aria-hidden=true href=#pseudo-inverse-controller>#</a></h3>
<p>Initialization in <code>__init__</code>:</p>
<ul>
<li>Initialize the leaf super class.</li>
<li>Store the plant context, this will help get the positions and vel of the robot.</li>
<li>Get the model instance for the robot.</li>
<li>Get the body frame and the world frame for the robot.</li>
<li>Get the start and end joints for the robot, this will help get the jacobian for the robot.</li>
<li>Set the input port of the leafsystem, this is essentially a input port to our system, in this case we are taking the desired vel from trajectory source.</li>
<li>In addition to the desired vel, we also need the position of the robot, so we are setting another input port for the position of the robot.</li>
<li>Set the output port of the leafsystem, this is an output port to our system, in this case we are giving the desired vel to the robot.</li>
<li>We are also connecting the output port to the function which will calculate the actual output. In my case this will be <code>CalcOutput</code> function.</li>
</ul>
<p>CalcOutput function:</p>
<ul>
<li>Get the current position of the robot and the desired vel from the input port by using the diagram context.</li>
<li>I set the plant pose based on the position, then calculate the jacobian of the robot with respoect to the end joint.</li>
<li>then removing the unwanted joints from the jacobian.</li>
<li>then I calculate the pseudo inverse of the jacobian and multiply it with the desired vel to get the actual vel.</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>
class PseudoInverseController(LeafSystem):
    def __init__(self, plant: MultibodyPlant):
        super().__init__()

        # store the plant for the controller use in future
        self._plant = plant

        # get the default context for the plant for the differential kinematics
        self._get_plant_context = plant.CreateDefaultContext()

        # get the model instance for the iiwa
        self._iiwa = plant.GetModelInstanceByName(&#34;iiwa&#34;)

        # these two are for views and transformations
        self._g = plant.GetBodyByName(&#34;body&#34;).body_frame()
        self._w = plant.world_frame()

        # get the start and end joints
        self._start_joint = plant.GetJointByName(&#34;iiwa_joint_1&#34;).velocity_start()
        self._end_joint = plant.GetJointByName(&#34;iiwa_joint_7&#34;).velocity_start()

        # start declaring the inputs nad output ports
        # input port for the desired velocity
        self.vel_input_port = self.DeclareVectorInputPort(&#34;V_WG&#34;, 6)
        # input port for the position of the robot
        self.q_word = self.DeclareVectorInputPort(&#34;iiwa.position&#34;, 7)
        # output port for the desired velocity
        self.DeclareVectorOutputPort(&#34;iiwa.velocity&#34;, 7, self.CalcOutput)
        # this is optional to store the trajectory data.
        self.save_data = []

    def CalcOutput(self, context, output):
        # get the current position of the robot
        q = self.q_word.Eval(context)

        # get the current velocity of the robot
        v = self.vel_input_port.Eval(context)

        # set the position to the robot. Still not sure why we need to do this.
        self._plant.SetPositions(self._get_plant_context, self._iiwa, q)

        # get the jacobian of the robot
        J = self._plant.CalcJacobianSpatialVelocity(
            self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w
        )
        J = J[:, self._start_joint : self._end_joint + 1]
        v = np.linalg.pinv(J).dot(v)
        self.save_data.append(v)
        
        output.SetFromVector(v)
</code></pre></div><h3 id=qp-controller>QP controller<a hidden class=anchor aria-hidden=true href=#qp-controller>#</a></h3>
<p>The next is the qp controller, this is a bit more complicated than the pseudo inverse controller.
Initialization in <code>__init__</code>:</p>
<ul>
<li>Initialization is same as the pseudo inverse controller.</li>
<li>In addition I also initializing a variable which will store the jacobian and the desired vel.</li>
</ul>
<p>CalcOutput function:</p>
<ul>
<li>Starting part of the function is same as the pseudo inverse controller.</li>
<li>After I find the jacobian, I solving a quadratic programming problem to find the actual vel, using the drake math program solver <code>Solve</code>.</li>
<li>I am using the <code>Solve</code> function to solve the mathmatical problem, which is defined in the <code>_define_math_problem</code> function.</li>
</ul>
<p>_define_math_problem function:</p>
<ul>
<li>This function is used to define the mathmatical problem for the qp solver.</li>
<li>I am using the <code>MathematicalProgram</code> class to define the problem.</li>
<li>I add the continous variable to the problem, which is the actual vel. ( here I am 15 variables, because the jacobian is also 6 * 15, there are some useless joints there, I kept it for fun, you can remove it if you want)</li>
<li>I add the bounding box constraint to the problem, this is to make sure the vel is within the limits.</li>
<li>I also calculate the error using the following equation $error = J * v - v_{desired}$</li>
<li>I add the cost to the problem, which is the error dot product with itself ( this make the error quadratic, which is needed for the qp solver)</li>
<li>I return the problem to the solve.</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>#TODO Need to make a controller super class in the future
class QPController(LeafSystem):
    def __init__(self, plant: MultibodyPlant):
        super().__init__()

        # store the plant for the controller use in future
        self._plant = plant

        # get the default context for the plant for the differential kinematics
        self._get_plant_context = plant.CreateDefaultContext()

        # get the model instance for the iiwa
        self._iiwa = plant.GetModelInstanceByName(&#34;iiwa&#34;)

        # these two are for views and transformations
        self._g = plant.GetBodyByName(&#34;body&#34;).body_frame()
        self._w = plant.world_frame()

        # get the start and end joints
        self._start_joint = plant.GetJointByName(&#34;iiwa_joint_1&#34;).velocity_start()
        self._end_joint = plant.GetJointByName(&#34;iiwa_joint_7&#34;).velocity_start()

        # start declaring the inputs nad output ports
        self.vel_input_port = self.DeclareVectorInputPort(&#34;V_WG&#34;, 6)
        self.q_word = self.DeclareVectorInputPort(&#34;iiwa.position&#34;, 7)
        self.DeclareVectorOutputPort(&#34;iiwa.velocity&#34;, 7, self.CalcOutput)
        self.save_data = [] 

        # Initialize the J and x with None
        self.J = None
        self.v = None

    def _define_math_problem(self, v_desired: np.ndarray):
        prog = MathematicalProgram()
        v = prog.NewContinuousVariables(15, &#34;v&#34;)
        v_max = 0.5
        error = self.J @ v - np.array(v_desired)
        prog.AddBoundingBoxConstraint(-v_max, v_max, v)
        prog.AddCost(error.dot(error))
        return prog



    def CalcOutput(self, context: Context, outputs: SystemOutput) -&gt; None:
        # get the current position of the robot
        q = self.q_word.Eval(context)

        # get the current velocity of the robot
        v = self.vel_input_port.Eval(context)

        # set the position to the robot. Still not sure why we need to do this.
        self._plant.SetPositions(self._get_plant_context, self._iiwa, q)

        # get the jacobian of the robot
        self.J = self._plant.CalcJacobianSpatialVelocity(
            self._get_plant_context, JacobianWrtVariable.kV, self._g, [0, 0, 0], self._w, self._w
        )

        # print(v.shape, v)
        result = Solve(self._define_math_problem(v))
        r = result.GetSolution(v)
        v = result.get_x_val()[:7]
        # print(result.get_x_val()[:7], &#34;This is the x val results&#34;)
        # print(r.shape, r)
        # v = np.array([print(dir(c[0])) for c in r])

        self.save_data.append(v)
        # print(v)
        # print(&#34;v&#34;, v, dir(v), type(v))
        # print(np.array(v), dir(v), type(v))
        outputs.SetFromVector(v)
</code></pre></div><ol start=8>
<li>Adding the controllers to the diagram.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # add the controller to the diagram
    controller = builder.AddSystem(PseudoInverseController(plant))
    # controller = builder.AddSystem(QPController(plant))
</code></pre></div><ol start=9>
<li>Add the integrator to the diagram. Since the controller return the vel, we need to integrate it to get the position.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # add the integrator to the diagram
    integrator = builder.AddSystem(Integrator(7))
</code></pre></div><ol start=10>
<li>Make all the connections.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # connections between the systems

    # 1. connect the desired velocity to the controller
    builder.Connect(V_G_source.get_output_port(), controller.GetInputPort(&#34;V_WG&#34;))

    # 2. connect the output of the controller to the integrator
    builder.Connect(controller.get_output_port(), integrator.get_input_port())

    # 3. connect the integrator to the iiwa position
    builder.Connect(integrator.get_output_port(), station.GetInputPort(&#34;iiwa.position&#34;))

    # 4. connect the iiwa state to the controller
    builder.Connect(station.GetOutputPort(&#34;iiwa.position_measured&#34;), controller.GetInputPort(&#34;iiwa.position&#34;))

    # calcualte connecting the gripper
    wsg_source = builder.AddSystem(TrajectorySource(traj_wsg_command))
    wsg_source.set_name(&#34;wsg.command&#34;)

    # 5. gripper position to the station
    builder.Connect(wsg_source.get_output_port(), station.GetInputPort(&#34;wsg.position&#34;))

    diagram = builder.Build()
    diagram.set_name(&#34;Testing_pick_and_place&#34;)
</code></pre></div><ol start=11>
<li>Visualize the diagram using pydot. I love this part of drake a LOT.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    # visualize the diagram
    print(&#34;Diagram built&#34;)
    pydot.graph_from_dot_data( diagram.GetGraphvizString())[0].write_svg(&#34;station_pick_place.svg&#34;)
</code></pre></div><ol start=12>
<li>Simulate the system.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>
    # simulate the diagram
    simulator = Simulator(diagram)
    context = simulator.get_mutable_context()
    station_context = station.GetMyContextFromRoot(context)

    integrator.set_integral_value(integrator.GetMyContextFromRoot(context),
                                    plant.GetPositions(
                                        plant.GetMyContextFromRoot(context),
                                        plant.GetModelInstanceByName(&#34;iiwa&#34;),
                                    ),
    )

    diagram.ForcedPublish(context)
    meshcat.StartRecording(set_visualizations_while_recording=True)
    simulator.AdvanceTo(vel_trajectory.end_time())
    meshcat.StopRecording()
    meshcat.PublishRecording()
</code></pre></div><ol start=13>
<li>Plot the results.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>    plt.plot(np.array(controller.save_data).reshape(-1,7))
    plt.show()
</code></pre></div><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2>
<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden>
<iframe src=https://www.youtube.com/embed/rtCUpqlqp20 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe>
</div>
<p>I tried embedding video, but hugo is not letting me, so here is the youtube video: <a href=https://youtu.be/rtCUpqlqp20>https://youtu.be/rtCUpqlqp20</a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://prakyathk.com/tags/drake/>Drake</a></li>
<li><a href=https://prakyathk.com/tags/manipulation/>Manipulation</a></li>
<li><a href=https://prakyathk.com/tags/robotics/>Robotics</a></li>
<li><a href=https://prakyathk.com/tags/introduction/>Introduction</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=https://prakyathk.com/>Pk blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>